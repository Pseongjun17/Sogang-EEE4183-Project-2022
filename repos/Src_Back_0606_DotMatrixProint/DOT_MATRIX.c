#include "DOT_MATRIX.h"

DotMatrix_t main_display;


const u8 font8x8[16][8] = {
    {0x3c, 0x42, 0x46, 0x4a, 0x52, 0x62, 0x3c, 0x00}, // 0
    {0x10, 0x30, 0x50, 0x10, 0x10, 0x10, 0x7c, 0x00}, // 1
    {0x3c, 0x42, 0x02, 0x0c, 0x30, 0x42, 0x7e, 0x00}, // 2
    {0x3c, 0x42, 0x02, 0x1c, 0x02, 0x42, 0x3c, 0x00}, // 3
    {0x08, 0x18, 0x28, 0x48, 0xfe, 0x08, 0x1c, 0x00}, // 4
    {0x7e, 0x40, 0x7c, 0x02, 0x02, 0x42, 0x3c, 0x00}, // 5
    {0x1c, 0x20, 0x40, 0x7c, 0x42, 0x42, 0x3c, 0x00}, // 6
    {0x7e, 0x42, 0x04, 0x08, 0x10, 0x10, 0x10, 0x00}, // 7
    {0x3c, 0x42, 0x42, 0x3c, 0x42, 0x42, 0x3c, 0x00}, // 8
    {0x3c, 0x42, 0x42, 0x3e, 0x02, 0x04, 0x38, 0x00}, // 9
    {0x18, 0x24, 0x42, 0x42, 0x7e, 0x42, 0x42, 0x00}, // A
    {0x7c, 0x22, 0x22, 0x3c, 0x22, 0x22, 0x7c, 0x00}, // B
    {0x1c, 0x22, 0x40, 0x40, 0x40, 0x22, 0x1c, 0x00}, // C
    {0x78, 0x24, 0x22, 0x22, 0x22, 0x24, 0x78, 0x00}, // D
    {0x7e, 0x22, 0x28, 0x38, 0x28, 0x22, 0x7e, 0x00}, // E
    {0x7e, 0x22, 0x28, 0x38, 0x28, 0x20, 0x70, 0x00}  // F
};


void init_dot_display(DotMatrix_t *display, enum GPIO_pin_number row, enum GPIO_pin_number col)
{
    init_GPIO_pin(&display->row_port, PushPullOut, row, MAT_SIZE);
    init_GPIO_pin(&display->col_port, PushPullOut, col, MAT_SIZE);

    display->turned_on_row = 0;
    // display->output = display->output_buf;
    display->output = font8x8[3];
    display->string_buf = 0;
    display->str_length = 0;


    display->is_rotated = 0;
    display->is_rolling = 0;
    display->is_blinking = 0;
    display->is_major_changed = 0;

    for(int i = 0 ; i < MAT_SIZE; i++)
        display->turn_off_Zeros[i] = 0;

    fast_interrupt_setup(ROW_SCAN_INTERVAL);    
}

void print_string_display(DotMatrix_t *display, char* str)
{

}

void setup_rolling(DotMatrix_t *display, bool is_rolling)
{

}

void turn_on_display(DotMatrix_t *display)
{

}

void turn_off_display(DotMatrix_t *display)
{

}


//////////////////////row scan////////////////////
void TIM3_IRQHandler(void)
{
    if ((TIM3->SR & 0x0001) != 0)
	{
		write_val_to_GPIO(&main_display.row_port, (~(1 << main_display.turned_on_row)) & 0xFF);
		write_val_to_GPIO(&main_display.col_port, main_display.output[main_display.turned_on_row] );

        main_display.turned_on_row++;
        if(main_display.turned_on_row == MAT_SIZE)
            main_display.turned_on_row = 0;
	}
	TIM3->SR &= ~(1 << 0); // clear UIF	
}